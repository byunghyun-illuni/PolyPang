# PolyPang 기술 스택 & 아키텍처

## 1. 기술 스택 선정 근거

### 1.1 렌더링 엔진: PixiJS

**선정 이유**:
- WebGL 기반 고성능 2D 렌더링 (60fps 안정적 유지)
- 파티클 시스템 내장 → Pang 이펙트 구현 용이
- 정N각형 동적 렌더링 최적화
- 모바일 성능 우수

**대안 대비 장점**:
- vs Canvas API: 파티클 시스템, 성능 최적화 기본 제공
- vs Three.js: 2D 게임에 불필요한 3D 오버헤드 없음
- vs Phaser: 더 세밀한 제어 가능, 번들 크기 작음

### 1.2 상태 관리: Zustand

**선정 이유**:
- 게임은 초당 30~60회 상태 업데이트 발생
- Context API는 불필요한 리렌더링 유발
- Zustand는 셀렉터로 세밀한 최적화 가능
- 보일러플레이트 최소 (Redux 대비)

**상태 구조**:
```typescript
// 3개의 독립적인 스토어로 분리
useGameStore    // gameState, ball, arena
useRoomStore    // roomCode, roomState, host
usePlayerStore  // players, myPlayerId, aliveCount
```

### 1.3 UI: Tailwind CSS + shadcn/ui

**선정 이유**:
- 모바일 퍼스트 (9:16 비율) 개발에 최적
- 유틸리티 클래스로 빠른 프로토타이핑
- shadcn/ui로 로비/결과 화면 컴포넌트 재사용
- styled-components 대비 런타임 오버헤드 없음

### 1.4 빌드 툴: Vite

**선정 이유**:
- CRA 대비 10배 이상 빠른 HMR
- PixiJS 같은 대형 라이브러리 로딩 최적화
- ESM 네이티브 지원
- 프로덕션 빌드 최적화 우수

### 1.5 TypeScript

**선정 이유**:
- 복잡한 게임 상태 타입 안정성 확보
- 물리 엔진 계산 로직 버그 사전 방지
- Socket 이벤트 타입 정의로 클라/서버 일관성 유지
- 협업 시 인텔리센스 제공

---

## 2. 클라이언트 아키텍처

### 2.1 폴더 구조

```
client/
├── src/
│   ├── components/
│   │   ├── ui/                    # shadcn/ui 컴포넌트
│   │   │   ├── button.tsx
│   │   │   ├── card.tsx
│   │   │   ├── input.tsx
│   │   │   └── toast.tsx
│   │   │
│   │   ├── arena/                 # ArenaView (PixiJS)
│   │   │   ├── ArenaCanvas.tsx           # PixiJS Stage 래퍼
│   │   │   ├── renderers/
│   │   │   │   ├── PolygonRenderer.ts    # 정N각형 Graphics
│   │   │   │   ├── PaddleRenderer.ts     # 패들 Sprite
│   │   │   │   ├── BallRenderer.ts       # 공 Sprite + Trail
│   │   │   │   └── SideRenderer.ts       # Side 색상/라벨
│   │   │   └── effects/
│   │   │       ├── HitPangEffect.ts      # 소형 파티클
│   │   │       └── OutPangEffect.ts      # 대형 파티클 + 카메라 쉐이크
│   │   │
│   │   ├── screens/               # 화면별 컴포넌트 (S01~S06)
│   │   │   ├── HomeScreen.tsx            # S01: 방 만들기/입장
│   │   │   ├── LobbyScreen.tsx           # S02: 로비
│   │   │   ├── GameScreen.tsx            # S04: 인게임
│   │   │   ├── SpectatorScreen.tsx       # S05: 관전
│   │   │   └── ResultScreen.tsx          # S06: 결과
│   │   │
│   │   └── shared/                # 공통 컴포넌트
│   │       ├── AppHeader.tsx
│   │       ├── PlayerList.tsx
│   │       ├── RoomCodePanel.tsx
│   │       ├── EmojiBar.tsx
│   │       ├── CountdownOverlay.tsx
│   │       └── TouchInputArea.tsx
│   │
│   ├── stores/                    # Zustand 스토어
│   │   ├── useGameStore.ts
│   │   ├── useRoomStore.ts
│   │   └── usePlayerStore.ts
│   │
│   ├── hooks/
│   │   ├── useGameLoop.ts         # requestAnimationFrame 루프
│   │   ├── useInput.ts            # 터치/키보드 입력 (좌우 홀드 방식)
│   │   ├── useSocketEvents.ts     # Socket 이벤트 구독
│   │   ├── usePredictiveRender.ts # 클라이언트 예측 렌더링
│   │   ├── useArenaRotation.ts    # 내 Side 하단 고정 회전 각도 계산
│   │   └── useConnectionStatus.ts # 연결 상태 모니터링 & 재연결
│   │
│   ├── physics/                   # 물리 계산 (클라/서버 공유 가능)
│   │   ├── geometry.ts            # 정N각형 좌표 계산
│   │   ├── collision.ts           # 충돌 감지
│   │   ├── reflection.ts          # 공 반사 각도
│   │   └── paddle.ts              # 패들 이동 물리
│   │
│   ├── utils/
│   │   ├── soundManager.ts        # Howler 래퍼
│   │   ├── constants.ts           # 게임 상수 (물리, 타이밍, 네트워크)
│   │   ├── colors.ts              # 플레이어 색상 팔레트
│   │   └── socketClient.ts        # Socket.io 클라이언트 래퍼
│   │
│   ├── types/                     # TypeScript 타입 정의
│   │   ├── game.types.ts
│   │   ├── room.types.ts
│   │   ├── player.types.ts
│   │   └── socket.types.ts
│   │
│   ├── App.tsx
│   ├── main.tsx                   # Vite 진입점
│   └── index.css                  # Tailwind 임포트
│
├── public/
│   ├── sounds/                    # 효과음
│   │   ├── hit-pang.mp3           # 패들 히트
│   │   ├── out-pang.mp3           # OUT 판정
│   │   ├── countdown-tick.mp3     # 3, 2, 1 카운트
│   │   ├── countdown-go.mp3       # GO!
│   │   ├── game-over.mp3          # 게임 종료
│   │   └── emoji-pop.mp3          # 이모지 리액션 (옵션)
│   └── assets/
│       └── logo.png
│
├── tailwind.config.js
├── tsconfig.json
├── vite.config.ts
└── package.json
```

### 2.2 데이터 흐름

```
[서버] Socket.io Event
    ↓
[useSocketEvents Hook] 이벤트 수신
    ↓
[Zustand Store] 상태 업데이트
    ↓
[React Components] 리렌더링
    ↓
[PixiJS Renderers] Canvas 렌더링 (60fps)
```

### 2.3 게임 루프 구조

```typescript
// hooks/useGameLoop.ts
export const useGameLoop = () => {
  const { ball, updateBall } = useGameStore();

  useEffect(() => {
    let animationFrameId: number;
    let lastTime = performance.now();

    const gameLoop = (currentTime: number) => {
      const deltaTime = (currentTime - lastTime) / 1000; // 초 단위
      lastTime = currentTime;

      // 클라이언트 예측 렌더링 (서버 상태로 보정)
      const predictedBall = predictBallPosition(ball, deltaTime);
      updateBall(predictedBall);

      animationFrameId = requestAnimationFrame(gameLoop);
    };

    animationFrameId = requestAnimationFrame(gameLoop);

    return () => cancelAnimationFrame(animationFrameId);
  }, []);
};
```

### 2.4 핵심 구현 로직

#### 2.4.1 내 Side 하단 고정 (Arena 회전)

**원칙**: 모든 플레이어는 자신의 Side가 화면 하단에 위치하도록 Arena가 회전되어 렌더링

**구현**:
```typescript
// hooks/useArenaRotation.ts
export const useArenaRotation = () => {
  const myPlayerIndex = usePlayerStore(s => s.myPlayerIndex);
  const playerCount = usePlayerStore(s => s.alivePlayers.length);

  // rotation = -θ_myIndex
  const myAngle = (360 / playerCount) * myPlayerIndex - 90;
  const rotation = -myAngle; // 반대 방향 회전

  return rotation; // 도 단위
};
```

**적용 위치**:
- `ArenaCanvas.tsx`: PixiJS Container 회전
- `renderers/`: 모든 렌더러는 회전된 좌표계 기준

#### 2.4.2 터치 입력 (좌우 홀드 방식)

**스펙**:
```typescript
// hooks/useInput.ts
interface TouchInputConfig {
  leftZone: { x: 0, width: '50%' };     // 화면 왼쪽 절반
  rightZone: { x: '50%', width: '50%' }; // 화면 오른쪽 절반
  holdBehavior: 'continuous';            // 누르는 동안 계속 이동
  releaseDeceleration: 0.9;              // 떼면 감속 계수
}
```

**동작**:
- 터치 홀드 → `paddle_move(LEFT/RIGHT)` 전송
- 터치 해제 → `paddle_move(STOP)` 전송
- PC: `A/D` 또는 `←/→` 키 동일 동작

#### 2.4.3 게임 상수 (constants.ts)

```typescript
// utils/constants.ts
export const GAME_CONSTANTS = {
  // Arena
  ARENA_RADIUS_RATIO: 0.38,        // ArenaView 대비 반지름 비율

  // Paddle
  PADDLE_LENGTH_RATIO: 0.3,        // α: Side 길이 대비 패들 길이
  PADDLE_MOVE_RANGE: 0.6,          // β: Side 중심 기준 이동 범위
  PADDLE_MAX_SPEED: 0.8,           // 최대 이동 속도 (Side 길이/초)
  PADDLE_ACCELERATION: 2.0,        // 가속도
  PADDLE_DECELERATION: 0.9,        // 감속 계수

  // Ball
  BALL_INITIAL_SPEED: 0.3,         // 초기 속도 (R/초)
  BALL_SPEED_INCREMENT: 1.05,      // HIT마다 5% 증가
  BALL_RADIUS_RATIO: 0.03,         // Arena 대비 공 크기

  // Timing
  COUNTDOWN_SECONDS: 3,
  OUT_SLOWMO_DURATION: 0.5,        // 슬로우모션 지속 (초)
  REMESH_ANIMATION_DURATION: 0.5,  // 리메시 애니메이션 (초)

  // Network
  SERVER_TICK_RATE: 30,            // 서버 초당 틱
  CLIENT_RENDER_FPS: 60,           // 클라이언트 렌더링
  RECONNECT_MAX_ATTEMPTS: 5,       // 재연결 최대 시도
  RECONNECT_INTERVAL: 2000,        // 재연결 간격 (ms)
} as const;
```

#### 2.4.4 색상 팔레트 (colors.ts)

```typescript
// utils/colors.ts
export const PLAYER_COLORS = [
  '#EF4444', // P1 빨강
  '#F97316', // P2 주황
  '#EAB308', // P3 노랑
  '#22C55E', // P4 초록
  '#06B6D4', // P5 청록
  '#3B82F6', // P6 파랑
  '#8B5CF6', // P7 보라
  '#EC4899', // P8 분홍
] as const;

export const MY_PADDLE_COLOR = '#FCD34D'; // 내 패들 강조색 (노란색)
export const OUT_PLAYER_COLOR = '#9CA3AF'; // OUT 플레이어 (회색)
```

#### 2.4.5 연결 상태 관리 (useConnectionStatus.ts)

**기능**:
- 연결 상태 모니터링 (ping 측정)
- 자동 재연결 (최대 5회, 2초 간격)
- 연결 품질 표시 (excellent/good/poor/disconnected)

**UI 표시**:
- Header 우측 연결 상태 아이콘 (📶/⚡/❌)
- poor/disconnected 시 재연결 토스트

---

## 3. 서버 아키텍처

### 3.1 폴더 구조

```
server/
├── src/
│   ├── game/
│   │   ├── engines/
│   │   │   ├── GameEngine.js          # 기존 베이스 클래스
│   │   │   └── PolyPangEngine.ts      # PolyPang 게임 엔진
│   │   │
│   │   ├── managers/
│   │   │   ├── ArenaManager.ts        # 정N각형 관리
│   │   │   ├── PhysicsEngine.ts       # 물리 시뮬레이션
│   │   │   └── CollisionDetector.ts   # 충돌 감지
│   │   │
│   │   └── GameRegistry.js            # 기존 레지스트리
│   │
│   ├── socket/
│   │   ├── index.js                   # 기존 소켓 핸들러
│   │   ├── gameHandlers.js            # 기존
│   │   ├── inputHandlers.ts           # 패들 입력 이벤트 (신규)
│   │   └── roomHandlers.ts            # 방 관리 (신규)
│   │
│   ├── utils/
│   │   └── geometry.ts                # client와 공유 가능
│   │
│   ├── types/
│   │   ├── game.types.ts
│   │   └── socket.types.ts
│   │
│   └── index.js
│
└── package.json
```

### 3.2 게임 루프 (Server-side)

```typescript
// game/managers/PhysicsEngine.ts
export class PhysicsEngine {
  private tickRate = 30; // 초당 30회
  private interval: NodeJS.Timeout;

  start() {
    this.interval = setInterval(() => {
      this.tick();
    }, 1000 / this.tickRate);
  }

  tick() {
    // 1. 공 위치 업데이트
    this.updateBallPosition();

    // 2. 충돌 감지
    const collision = this.detectCollision();

    // 3. OUT 판정
    if (collision.type === 'OUT') {
      this.handlePlayerOut(collision.playerId);
    }

    // 4. 상태 브로드캐스트
    this.broadcastGameState();
  }
}
```

---

## 4. 성능 최적화 전략

### 4.1 렌더링 최적화

1. **PixiJS 최적화**
   - Sprite 풀링: Pang 이펙트 재사용
   - Batch 렌더링: 정N각형 선분 묶음 처리
   - Culling: 화면 밖 객체 렌더링 스킵

2. **React 최적화**
   - Zustand 셀렉터: 필요한 상태만 구독
   - React.memo: 불필요한 리렌더링 방지
   - ArenaCanvas는 React 외부로 분리

### 4.2 네트워크 최적화

1. **상태 동기화**
   - 서버→클라: 30fps 브로드캐스트 (33ms 간격)
   - 클라→서버: 입력 이벤트만 즉시 전송
   - Delta compression: 변경된 상태만 전송

2. **예측 렌더링**
   - 클라이언트는 서버 상태 기반으로 예측
   - 서버 상태 도착 시 보정 (lerp)

### 4.3 메모리 최적화

1. **객체 재사용**
   - 파티클 풀링
   - Vector2D 객체 재사용

2. **가비지 컬렉션 최소화**
   - 게임 루프 내 객체 생성 최소화
   - 프리미티브 값 우선 사용

---

## 5. 개발 단계별 마일스톤

### Phase 1: 인프라 + 기본 UI (1주)

**목표**: 프로젝트 셋업 + S01(홈), S02(로비) 기본 화면

- [ ] Vite + TypeScript 프로젝트 마이그레이션
- [ ] Tailwind CSS + shadcn/ui 설정
- [ ] Zustand 스토어 구조 설계
- [ ] Socket.io 클라이언트/서버 연결
- [ ] **S01 (홈)**: 방 만들기/입장 UI
- [ ] **S02 (로비)**: 플레이어 리스트, Ready 버튼
- [ ] Room 생성/참가 로직 (서버)

### Phase 2: 게임 로직 + 인게임 핵심 (1.5주)

**목표**: S04(인게임) 핵심 플레이 구현

- [ ] PixiJS ArenaCanvas 기본 렌더링
- [ ] 정N각형 좌표 계산 (geometry.ts)
- [ ] **내 Side 하단 고정** 회전 로직 (useArenaRotation)
- [ ] 서버 물리 엔진 (공 이동, 반사, 충돌)
- [ ] **터치/키보드 입력** 처리 (useInput)
- [ ] Paddle 이동 & Ball 렌더링
- [ ] **S04 (인게임)**: Arena + 조작 영역
- [ ] OUT 판정 & Arena 리메시 로직

### Phase 3: 연출 + 관전/결과 화면 (1.5주)

**목표**: S03(카운트다운), S05(관전), S06(결과) + 이펙트

- [ ] **S03 (카운트다운)**: 3-2-1-GO 오버레이
- [ ] HIT/OUT Pang 파티클 이펙트
- [ ] 경기장 리메시 애니메이션 (0.5초)
- [ ] Howler 사운드 통합 (6개 효과음)
- [ ] **S05 (관전)**: EmojiBar + 이모지 리액션
- [ ] **S06 (결과)**: 우승자/순위 표시
- [ ] Framer Motion 화면 전환

### Phase 4: 최적화 & QA (1주)

**목표**: 전체 화면 폴리싱 + 성능 최적화

- [ ] 성능 프로파일링 (PixiJS, Zustand)
- [ ] 모바일 최적화 (터치 반응성, 60fps 유지)
- [ ] 네트워크 지연 테스트 (재연결 로직)
- [ ] S01~S06 전체 화면 통합 테스트
- [ ] 버그 수정 & 엣지 케이스 처리

---

## 6. 환경 변수 설정

### Client (.env)
```bash
VITE_SERVER_URL=http://localhost:3001
VITE_SOCKET_PATH=/socket.io
```

### Server (.env)
```bash
PORT=3001
CLIENT_URL=http://localhost:5173
CORS_ORIGIN=http://localhost:5173
```

---

## 7. 배포 전략

### 개발 환경
- Client: Vite Dev Server (localhost:5173)
- Server: Nodemon (localhost:3001)

### 프로덕션 환경
- Client: Vercel / Netlify
- Server: Railway / Fly.io
- WebSocket: Socket.io (자동 폴백)

---

## 8. 테스트 전략

### 단위 테스트
- 물리 계산 로직 (geometry, collision, reflection)
- Zustand 스토어 액션

### 통합 테스트
- Socket 이벤트 흐름
- 게임 상태 동기화

### E2E 테스트
- Playwright로 멀티플레이어 시나리오 테스트

---

## 9. 참고 자료

- [PixiJS 공식 문서](https://pixijs.com/guides)
- [Zustand 문서](https://zustand-demo.pmnd.rs/)
- [Tailwind CSS](https://tailwindcss.com/docs)
- [shadcn/ui](https://ui.shadcn.com/)
- [Vite 가이드](https://vitejs.dev/guide/)
- [Socket.io](https://socket.io/docs/v4/)
